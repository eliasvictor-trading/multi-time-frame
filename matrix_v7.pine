// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © EliasVictor

//@version=6 
indicator("MTF Checklist Dashboard - v2.0", overlay=true, max_lines_count=500, max_labels_count=500, max_boxes_count=50)


//-----------------------------
// Inputs - Basic Settings
//-----------------------------
timeframes    = input.string("1,5,15,30,60,240", "Timeframes (comma-separated)", group="Basic Settings")
showHdr       = input.bool(true, "Show Header", group="Basic Settings")
orbMinutes    = input.int(15, "ORB Minutes", minval=1, group="Basic Settings")
nearPct       = input.float(0.20, "Near % for daily highs/lows", step=0.05, group="Basic Settings")
useCloseForPx = input.bool(true, "Use close for comparisons", group="Basic Settings")


tablePos = input.string("Top Right", "Dashboard Position", options=["Top Left", "Top Center", "Top Right", "Middle Left", "Middle Center", "Middle Right", "Bottom Left", "Bottom Center", "Bottom Right"], group="Display")


//-----------------------------
// Inputs - Signal Filters
//-----------------------------
minConfluence = input.int(5, "Minimum Timeframes Aligned (3-6)", minval=3, maxval=6, tooltip="Higher = fewer but more accurate signals", group="Confluence Filters")
requireHTF    = input.bool(true, "Require Higher Timeframe Confirmation", tooltip="Ensures 4hr, 1hr, 30min are aligned", group="Confluence Filters")
minHTF        = input.int(2, "Min Higher Timeframes (30m/1h/4h)", minval=1, maxval=3, group="Confluence Filters")


useVolFilter  = input.bool(true, "Volume Confirmation", group="Volume Filter")
volMultiplier = input.float(1.5, "Volume vs Average", minval=1.0, maxval=3.0, step=0.1, tooltip="1.5 = Requires 150% of average volume", group="Volume Filter")
volLength     = input.int(20, "Volume Average Length", minval=10, maxval=100, group="Volume Filter")


useAtrFilter  = input.bool(true, "Volatility Filter (ATR)", group="Volatility Filter")
atrLength     = input.int(14, "ATR Length", minval=5, maxval=50, group="Volatility Filter")
atrMinMult    = input.float(0.5, "Min ATR vs Average", minval=0.3, maxval=2.0, step=0.1, tooltip="0.5 = 50% of average ATR", group="Volatility Filter")


useOrbDist    = input.bool(true, "ORB Breakout Distance Required", group="ORB Filters")
orbDistPct    = input.float(0.10, "Min Breakout % Beyond ORB", minval=0.0, maxval=1.0, step=0.05, tooltip="0.10 = Price must be 0.1% beyond ORB level", group="ORB Filters")


useSessionFilter = input.bool(true, "Trade Only During Best Hours", group="Session Filter")
session1      = input.string("0930-1130", "Session 1 (EST)", group="Session Filter")
session2      = input.string("1400-1530", "Session 2 (EST)", group="Session Filter")


useMomentumFilter = input.bool(true, "Recent Momentum Required", group="Momentum Filter")
momentumBars  = input.int(3, "Lookback Bars", minval=2, maxval=10, group="Momentum Filter")


blockNearExtremes = input.bool(true, "Block Signals Near Daily Extremes", group="Daily Range Filter")
extremePct    = input.float(2.0, "Distance from High/Low %", minval=0.5, maxval=5.0, step=0.5, tooltip="Won't signal near extremes", group="Daily Range Filter")


useCandleFilter = input.bool(true, "Strong Directional Candle", group="Candle Filter")
candleBodyPct = input.float(60.0, "Min Candle Body %", minval=40.0, maxval=90.0, step=5.0, tooltip="60 = Body must be 60%+ of range", group="Candle Filter")


//-----------------------------
// Visual Signals Options
//-----------------------------
showSignals   = input.bool(true, "Show Entry Signals", group="Visual Signals")
showArrows    = input.bool(true, "Show Arrows", group="Visual Signals")
showBgColor   = input.bool(true, "Background Color", group="Visual Signals")


//-----------------------------
// Parse timeframes
//-----------------------------
var string[] tfs = array.new_string()
if barstate.isfirst
    for tf in str.split(timeframes, ",")
        array.push(tfs, str.trim(tf))


//-----------------------------
// Daily Data (non-repainting)
//-----------------------------
isNewSession = ta.change(time("D")) != 0
var float dayHigh = na
var float dayLow = na
var float pDayHigh = na
var float pDayLow = na
// Seed previous-day data from a non-repainting daily request so limited
// chart history still renders yesterday's range immediately.
[prevDayHighSeed, prevDayLowSeed] = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead=barmerge.lookahead_off)

if barstate.isfirst
    dayHigh := high
    dayLow := low

if na(pDayHigh)
    pDayHigh := prevDayHighSeed
if na(pDayLow)
    pDayLow := prevDayLowSeed

if isNewSession
    pDayHigh := dayHigh
    pDayLow := dayLow
    dayHigh := high
    dayLow := low
else
    dayHigh := na(dayHigh) ? high : math.max(dayHigh, high)
    dayLow := na(dayLow) ? low : math.min(dayLow, low)


//-----------------------------
// ORB Calculation
//-----------------------------
orbRes = str.tostring(orbMinutes)
var float ORH = na
var float ORL = na
var bool orbSet = false


if isNewSession
    orbSet := false
    ORH := na
    ORL := na


[orbHigh, orbLow, orbNewDay] = request.security(syminfo.tickerid, orbRes, [high, low, ta.change(time("D"))], lookahead=barmerge.lookahead_off)


if not orbSet and not na(orbNewDay) and orbNewDay != 0
    ORH := orbHigh
    ORL := orbLow
    orbSet := true


if na(ORH) or na(ORL)
    ORH := orbHigh
    ORL := orbLow


//-----------------------------
// Filter Calculations
//-----------------------------
avgVolume = ta.sma(volume, volLength)
volumeConfirmed = volume > avgVolume * volMultiplier
priceBasis = useCloseForPx ? close : hl2


atrCurrent = ta.atr(atrLength)
atrAvg = ta.sma(atrCurrent, 50)
atrConfirmed = atrCurrent > atrAvg * atrMinMult


inSession1 = timeframe.isticks or timeframe.isseconds ? time("1", session1, "America/New_York") : time(timeframe.period, session1, "America/New_York")
inSession2 = timeframe.isticks or timeframe.isseconds ? time("1", session2, "America/New_York") : time(timeframe.period, session2, "America/New_York")
inGoodSession = not na(inSession1) or not na(inSession2)


longMomentum = close > close[momentumBars] and high > high[1]
shortMomentum = close < close[momentumBars] and low < low[1]


distFromHigh = na(dayHigh) ? na : ((dayHigh - priceBasis) / priceBasis) * 100.0
distFromLow = na(dayLow) ? na : ((priceBasis - dayLow) / priceBasis) * 100.0
notNearHigh = na(distFromHigh) ? true : distFromHigh > extremePct
notNearLow = na(distFromLow) ? true : distFromLow > extremePct


candleRange = high - low
candleBody = math.abs(close - open)
bodyPercent = candleRange > 0 ? (candleBody / candleRange) * 100.0 : 0
strongBullCandle = close > open and bodyPercent >= candleBodyPct
strongBearCandle = close < open and bodyPercent >= candleBodyPct


//-----------------------------
// Table Setup
//-----------------------------
dashPos = tablePos == "Top Left" ? position.top_left : tablePos == "Top Center" ? position.top_center : tablePos == "Top Right" ? position.top_right : tablePos == "Middle Left" ? position.middle_left : tablePos == "Middle Center" ? position.middle_center : tablePos == "Middle Right" ? position.middle_right : tablePos == "Bottom Left" ? position.bottom_left : tablePos == "Bottom Center" ? position.bottom_center : position.bottom_right


var table dash = table.new(dashPos, 10, 4 + array.size(tfs), border_width=1)
row = 0


colBull = color.new(color.lime, 0)
colBear = color.new(color.red, 0)
colNeu  = color.new(color.yellow, 0)
colText = color.new(color.white, 0)
colHdr  = color.new(color.silver, 0)
colBack = color.new(color.black, 0)


if barstate.islast and showHdr
    table.cell(dash, 0, 0, "TF", bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 1, 0, "C",  bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 2, 0, "P",  bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 3, 0, "ORB",bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 4, 0, "VWAP",bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 5, 0, "E200",bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 6, 0, "D Hi/Lo",bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 7, 0, "PD Hi/Lo",bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 8, 0, "9 vs 21",bgcolor=colHdr, text_color=color.black)
    table.cell(dash, 9, 0, "9&21 v200",bgcolor=colHdr, text_color=color.black)


//-----------------------------
// Helper Functions
//-----------------------------
nearCheck(price, hi, lo, pct) =>
    condHi = math.abs(price - hi) <= price * (pct / 100.0)
    condLo = math.abs(price - lo) <= price * (pct / 100.0)
    condHi ? "Hi" : condLo ? "Lo" : "Mid"


getMTFData() =>
    e9   = ta.ema(close, 9)
    e21  = ta.ema(close, 21)
    e200 = ta.ema(close, 200)
    vw   = ta.vwap
    mid  = hl2
    [close, open, close[1], open[1], e9, e21, e200, vw, mid]


//-----------------------------
// Multi-Timeframe Loop
//-----------------------------
for i = 0 to array.size(tfs) - 1
    tf = array.get(tfs, i)
    row := i + 1
    [cTF, oTF, pcTF, poTF, e9, e21, e200, vwapTF, midTF] = request.security(syminfo.tickerid, tf, getMTFData(), lookahead=barmerge.lookahead_off)
    currBull = cTF >= oTF
    prevBull = pcTF >= poTF
    priceNow = useCloseForPx ? cTF : midTF
    orbPos = priceNow > ORH ? "A" : priceNow < ORL ? "B" : "W"
    vwapPos = priceNow >= vwapTF ? "A" : "B"
    e200Pos = priceNow >= e200 ? "A" : "B"
    nearToday = nearCheck(priceNow, dayHigh, dayLow, nearPct)
    nearPrev  = nearCheck(priceNow, pDayHigh, pDayLow, nearPct)
    nineVs21  = e9 >= e21 ? "A" : "B"
    pairVs200 = (e9 >= e200 and e21 >= e200) ? ">>" : (e9 < e200 and e21 < e200) ? "<<" : "<>"
    clrC   = currBull ? colBull : colBear
    clrP   = prevBull ? colBull : colBear
    clrORB = orbPos == "A" ? colBull : orbPos == "B" ? colBear : colNeu
    clrVW  = vwapPos == "A" ? colBull : colBear
    clrE2  = e200Pos == "A" ? colBull : colBear
    clrD   = nearToday == "Hi" ? colBull : nearToday == "Lo" ? colBear : colNeu
    clrPD  = nearPrev  == "Hi" ? colBull : nearPrev  == "Lo" ? colBear : colNeu
    clr921 = nineVs21 == "A" ? colBull : colBear
    clrAll = pairVs200 == ">>" ? colBull : pairVs200 == "<<" ? colBear : colNeu
    if barstate.islast
        table.cell(dash, 0, row, tf, bgcolor=colBack, text_color=colText)
        table.cell(dash, 1, row, currBull ? "G" : "R", bgcolor=clrC,  text_color=colText)
        table.cell(dash, 2, row, prevBull ? "G" : "R", bgcolor=clrP,  text_color=colText)
        table.cell(dash, 3, row, orbPos, bgcolor=clrORB, text_color=colText)
        table.cell(dash, 4, row, vwapPos, bgcolor=clrVW,  text_color=colText)
        table.cell(dash, 5, row, e200Pos, bgcolor=clrE2,  text_color=colText)
        table.cell(dash, 6, row, nearToday, bgcolor=clrD, text_color=colText)
        table.cell(dash, 7, row, nearPrev, bgcolor=clrPD, text_color=colText)
        table.cell(dash, 8, row, nineVs21, bgcolor=clr921, text_color=colText)
        table.cell(dash, 9, row, pairVs200, bgcolor=clrAll, text_color=colText)


//-----------------------------
// Add ORB Range, Current Day, and Previous Day Rows
//-----------------------------
if barstate.islast
    // ORB Range Row
    orbRangeRow = array.size(tfs) + 1
    orbRange = math.abs(ORH - ORL)
    orbRangeText = "ORB Range (" + str.tostring(orbMinutes) + "m)"
    orbPriceText = "H: " + str.tostring(ORH, format.mintick) + " | L: " + str.tostring(ORL, format.mintick) + " | R: " + str.tostring(orbRange, format.mintick)
    table.cell(dash, 0, orbRangeRow, orbRangeText, bgcolor=color.new(color.blue, 70), text_color=colText)
    table.merge_cells(dash, 0, orbRangeRow, 4, orbRangeRow)
    table.cell(dash, 5, orbRangeRow, orbPriceText, bgcolor=color.new(color.blue, 70), text_color=colText)
    table.merge_cells(dash, 5, orbRangeRow, 9, orbRangeRow)
    
    // Current Day High/Low Row
    cdRow = array.size(tfs) + 2
    cdText = "Current Day"
    cdPriceText = "High: " + str.tostring(dayHigh, format.mintick) + " | Low: " + str.tostring(dayLow, format.mintick)
    table.cell(dash, 0, cdRow, cdText, bgcolor=color.new(color.orange, 70), text_color=colText)
    table.merge_cells(dash, 0, cdRow, 4, cdRow)
    table.cell(dash, 5, cdRow, cdPriceText, bgcolor=color.new(color.orange, 70), text_color=colText)
    table.merge_cells(dash, 5, cdRow, 9, cdRow)
    
    // Previous Day High/Low Row
    pdRow = array.size(tfs) + 3
    pdText = "Previous Day"
    pdPriceText = "High: " + str.tostring(pDayHigh, format.mintick) + " | Low: " + str.tostring(pDayLow, format.mintick)
    table.cell(dash, 0, pdRow, pdText, bgcolor=color.new(color.purple, 70), text_color=colText)
    table.merge_cells(dash, 0, pdRow, 4, pdRow)
    table.cell(dash, 5, pdRow, pdPriceText, bgcolor=color.new(color.purple, 70), text_color=colText)
    table.merge_cells(dash, 5, pdRow, 9, pdRow)


//-----------------------------
// Alert Logic with Filters
//-----------------------------
priceNow = priceBasis
longScore = 0
shortScore = 0
htfScoreLong = 0
htfScoreShort = 0


for i = 0 to array.size(tfs) - 1
    tf = array.get(tfs, i)
    [cTF, oTF, pcTF, poTF, e9, e21, e200, vwapTF, midTF] = request.security(syminfo.tickerid, tf, getMTFData(), lookahead=barmerge.lookahead_off)
    priceTF = useCloseForPx ? cTF : midTF
    isBullish = (cTF >= oTF) and (priceTF >= vwapTF) and (priceTF >= e200) and (e9 >= e21) and (e9 >= e200 and e21 >= e200)
    isBearish = (cTF < oTF) and (priceTF < vwapTF) and (priceTF < e200) and (e9 < e21) and (e9 < e200 and e21 < e200)
    if isBullish
        longScore += 1
    if isBearish
        shortScore += 1
    if i >= 3
        if isBullish
            htfScoreLong += 1
        if isBearish
            htfScoreShort += 1


confluenceOK_Long = longScore >= minConfluence
confluenceOK_Short = shortScore >= minConfluence
htfOK_Long = not requireHTF or htfScoreLong >= minHTF
htfOK_Short = not requireHTF or htfScoreShort >= minHTF


orbRange = math.abs(ORH - ORL)
orbBreakoutDist = orbRange * (orbDistPct / 100.0)
longOrbConfirmed = useOrbDist ? priceNow > (ORH + orbBreakoutDist) : priceNow > ORH
shortOrbConfirmed = useOrbDist ? priceNow < (ORL - orbBreakoutDist) : priceNow < ORL


volOK = not useVolFilter or volumeConfirmed
atrOK = not useAtrFilter or atrConfirmed
sessionOK = not useSessionFilter or inGoodSession
momentumOK_Long = not useMomentumFilter or longMomentum
momentumOK_Short = not useMomentumFilter or shortMomentum
rangeOK_Long = not blockNearExtremes or notNearHigh
rangeOK_Short = not blockNearExtremes or notNearLow
candleOK_Long = not useCandleFilter or strongBullCandle
candleOK_Short = not useCandleFilter or strongBearCandle


longEntry = confluenceOK_Long and htfOK_Long and longOrbConfirmed and volOK and atrOK and sessionOK and momentumOK_Long and rangeOK_Long and candleOK_Long
shortEntry = confluenceOK_Short and htfOK_Short and shortOrbConfirmed and volOK and atrOK and sessionOK and momentumOK_Short and rangeOK_Short and candleOK_Short


longExit = shortScore >= 3
shortExit = longScore >= 3


//-----------------------------
// Visual Signals - Arrows Only
//-----------------------------
plotshape(showSignals and showArrows and longEntry, title="Long Arrow", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.small)
plotshape(showSignals and showArrows and shortEntry, title="Short Arrow", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.small)
bgcolor(showSignals and showBgColor and longEntry ? color.new(color.green, 92) : showSignals and showBgColor and shortEntry ? color.new(color.red, 92) : na)


alertcondition(longEntry, title="Long Entry Signal", message='{"ticker": "{{ticker}}", "action": "buy", "price": {{close}}, "quantity": 1}')
alertcondition(shortEntry, title="Short Entry Signal", message='{"ticker": "{{ticker}}", "action": "sell", "price": {{close}}, "quantity": 1}')
alertcondition(longExit, title="Long Exit Signal", message='{"ticker": "{{ticker}}", "action": "sell", "price": {{close}}}')
alertcondition(shortExit, title="Short Exit Signal", message='{"ticker": "{{ticker}}", "action": "buy", "price": {{close}}}')
